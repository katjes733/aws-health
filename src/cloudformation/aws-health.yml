# MIT License
#
# Copyright (c) 2022 Martin Macecek
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
AWSTemplateFormatVersion: 2010-09-09
Description: AWS Health Notification to Teams or Slack

# -----------------------------------------------------------------------------
# Parameters
# -----------------------------------------------------------------------------
Parameters:
  ResourcePrefix:
    Description: The prefix for all resources. If empty, auto generated by AWS including the name of the stack.
    Type: String
    Default: 'mac-'
    AllowedPattern: ^$|^[a-z0-9-]{0,7}$
  TagOwner:
    Description: The owner tag for all supported resources
    ConstraintDescription: "Must be a valid email address for the owner."
    Type: String
    AllowedPattern: ^[\w\.]+\@[\w]+\.[a-z]+$
  TagType:
    Description: The type tag for all supported resources
    ConstraintDescription: "Must be one of the following values only: Internal or External."
    Type: String
    AllowedValues: 
      - Internal
      - External
  TagUsage:
    Description: The usage tag for all supported resources
    ConstraintDescription: "Must be one of the following values only: Playground, Development, Qualification, Production or Control Tower."
    Type: String
    AllowedValues: 
      - Playground
      - Development
      - Qualification
      - Production
      - Control Tower
  TeamsHookUrl:
    Description: The Teams Hook URL
    Type: String
    Default: ''
    AllowedPattern: '^$|^https:\/\/[a-zA-Z0-9_\-\+]+(\.[a-zA-Z0-9_\-\+]+)+\/.+$'
  SlackHookUrl:
    Description: The Slack Hook URL
    Type: String
    Default: ''
    AllowedPattern: '^$|^https:\/\/[a-zA-Z0-9_\-\+]+(\.[a-zA-Z0-9_\-\+]+)+\/.+$'
  ExecutionRate:
    Description: The execution rate in minutes
    Type: Number
    Default: 10
    MinValue: 1
    MaxValue: 60

# -----------------------------------------------------------------------------
# Metadata:
# -----------------------------------------------------------------------------
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Health Configuration
        Parameters:
          - TeamsHookUrl
          - SlackHookUrl
          - ExecutionRate
      - Label:
          default: Deployment Configuration
        Parameters:
          - ResourcePrefix
          - TagOwner
          - TagType
          - TagUsage
    ParameterLabels:
      TeamsHookUrl: 
        default: Teams Webhook URL
      SlackHookUrl: 
        default: Slack Webhook URL
      ExecutionRate: 
        default: Execution Rate
      ResourcePrefix:
        default: Resource Prefix
      TagOwner:
        default: Tag Owner
      TagType:
        default: Tag Type
      TagUsage:
        default: Tag Usage

# -----------------------------------------------------------------------------
# Conditions
# -----------------------------------------------------------------------------
Conditions:
  IsOneMinute: !Equals [!Ref ExecutionRate, 1]
  UseSpecificResourcePrefix: !Not [!Equals [!Ref ResourcePrefix, '']]
  IsArmSupportedRegion: !Or [!Equals ['us-east-1', !Ref AWS::Region], !Equals ['us-west-2', !Ref AWS::Region], !Equals ['eu-central-1', !Ref AWS::Region], !Equals ['eu-west-1', !Ref AWS::Region], !Equals ['ap-south-1', !Ref AWS::Region], !Equals ['ap-southeast-1', !Ref AWS::Region], !Equals ['ap-southeast-2', !Ref AWS::Region], !Equals ['ap-northeast-1', !Ref AWS::Region]]

# -----------------------------------------------------------------------------
# Resources
# -----------------------------------------------------------------------------
Resources: 
  AwsHealthNotificationLambdaRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}AwsHealthNotificationLambdaRole', !Ref AWS::NoValue]
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Tags:
        - Key: Owner
          Value: !Ref TagOwner
        - Key: Type
          Value: !Ref TagType
        - Key: Usage
          Value: !Ref TagUsage

  AwsHealthNotificationLambdaRolePolicy:
    Type: 'AWS::IAM::Policy'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W12
            reason: '* needed, actions do not support resource level permissions'
    Properties:
      PolicyName: !Sub 
        - '${ResourcePrefix}AwsHealthNotificationLambdaRolePolicy'
        - { ResourcePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, '${AWS::StackName}-'] }
      PolicyDocument:        
        Statement:    
          - Sid: HealthReadAll
            Effect: Allow
            Action:
              - 'health:DescribeEvents'
            Resource: '*'
          - Sid: HealthReadEvents
            Effect: Allow
            Action:
              - 'health:DescribeEventDetails'
            Resource: 'arn:aws:health:*::event/*/*/*'
        Version: 2012-10-17      
      Roles:
        - !Ref AwsHealthNotificationLambdaRole

  AwsHealthNotificationLambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      RetentionInDays: 7
      LogGroupName: !Sub 
        - '/aws/lambda/${ResourcePrefix}AwsHealthNotification'
        - { ResourcePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, '${AWS::StackName}-' ] }
      Tags:
        - Key: Owner
          Value: !Ref TagOwner
        - Key: Type
          Value: !Ref TagType
        - Key: Usage
          Value: !Ref TagUsage

  AwsHealthNotificationLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: "Provided by managed policy AWSLambdaBasicExecutionRole in AwsHealthNotificationLambdaRole"
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    DependsOn: AwsHealthNotificationLambdaLogGroup
    Properties:
      FunctionName: !Sub 
        - '${ResourcePrefix}AwsHealthNotification'
        - { ResourcePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, '${AWS::StackName}-' ] }      
      Architectures:  
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code: 
        ZipFile: |
          import json, os, logging, boto3, re
          from datetime import timedelta
          from datetime import datetime
          from urllib.request import Request, urlopen
          from urllib.error import URLError, HTTPError
          from dateutil import parser

          THU = os.environ['TeamsHookUrl']
          SHU = os.environ['SlackHookUrl']
          CI = int(os.environ['CheckTime'])

          levels = {
              'critical': logging.CRITICAL,
              'error': logging.ERROR,
              'warn': logging.WARNING,
              'info': logging.INFO,
              'debug': logging.DEBUG
          }
          logger = logging.getLogger()
          try:
              logger.setLevel(levels.get(os.getenv('LOG_LEVEL', 'info').lower()))
          except KeyError as e:
              logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("event: %s", event)
              if event and "detail" in event and event['detail']:
                  prep_message(event['detail'])
              else:
                  hClient = boto3.client('health')
                  toDt = parser.parse(event['time'])
                  fromDt = toDt - timedelta(minutes=CI)
                  allEvents = hClient.describe_events(filter={'eventTypeCategories': ['issue'], 'lastUpdatedTimes': [{'from': fromDt, 'to': toDt}]})['events']
                  eventArns = list(map(lambda event: event['arn'],[x for x in allEvents if "eventScopeCode" in x and x['eventScopeCode'] == "PUBLIC"]))
                  if eventArns:
                      eDs = hClient.describe_event_details(eventArns=eventArns)['successfulSet']
                      for eD in eDs:
                          prep_message(eD)
                  else:
                      logger.info("No new events and therefore nothing to send")

          def prep_message(eD):
              logger.info("eventDetail: %s", eD)
              if THU or SHU:
                  if "event" in eD:
                      ev = eD['event']
                  else:
                      ev = eD
                  c = "ff0000" if ev['statusCode']=="open" else "00ff00"
                  dt_f = ev['lastUpdatedTime'].strftime('%Y-%m-%d %H:%M:%S').split(' ')
                  eL = eD['eventDescription']['latestDescription'].split('\n')
                  lED = sorted(list(filter(lambda e: re.search(r"^\[(\d{2}:\d{2} [APM]{2}).*", e), eL)), key = lambda e: datetime.strptime(re.search(r"^\[(\d{2}:\d{2} [APM]{2})", e).group(1), "%I:%M %p"))[-1]
                  iSD = list(filter(lambda e: re.search(r"^The following AWS services.*", e), eL))
                  iS = event['service']
                  if iSD:
                      iSE = re.split(r':\s?', iSD[-1])
                      iSL = re.sub(r',\s?', '\n• ', iSE[1].replace(".", ""))
                      iS = f"{iSE[0]}:\n• {iSL}"
                  iUrl = f"https://phd.aws.amazon.com/phd/home?region={ev['region']}#/dashboard/open-issues?eventID={ev['arn']}&eventTab=details"
                  if THU:
                      prep_message_teams(ev, lED, iS, c, dt_f, iUrl)
                  if SHU:
                      prep_message_slack(ev, lED, iS, c, dt_f, iUrl)
              else:
                  logger.info("No Teams or Slack URL; no further processing")

          def prep_message_teams(ev, lED, iS, c, dt_f, iUrl):
              message = {
                  "@context": "https://schema.org/extensions",
                  "@type": "MessageCard",
                  "themeColor": f"{c}",
                  "title": f"{ev['statusCode'].capitalize()} Health Notification for {ev['service']}",
                  "sections": [{
                      "activityTitle": f"**{ev['eventTypeCode']}** is in Status **{ev['statusCode']}**",
                      "activitySubtitle": f"{dt_f[0]}, {dt_f[1]} UTC",
                      "facts": [
                          {"name": "Service:", "value": f"{ev['service']}"},
                          {"name": "Region:", "value": f"{ev['region']}"},
                          {"name": "Event Type Code:", "value": f"{ev['eventTypeCode']}"},
                          {"name": "Status:", "value": f"{ev['statusCode']}"},
                          {"name": "Latest Description:", "value": f"{lED}"},
                          {"name": "Affected AWS Services:", "value": f"{iS}"}
                      ]
                  }],
                  "summary": f"Service {ev['eventTypeCode']}",
                  "potentialAction" : [{
                      "@type": "OpenUri", "name": "Go to Issue", "targets": [{"os": "default", "uri": iUrl}]
                  }]
              }
              post_message(THU, message)

          def prep_message_slack(ev, lED, iS, c, dt_f, iUrl):
              message = {
                  "attachments": [
                      {
                          "color": c,
                          "blocks": [
                              {"type": "header", "text": {"type": "plain_text", "text": f"{ev['statusCode'].capitalize()} Health Notification for {ev['service']}"}},
                              {"type": "section", "text": {"type": "mrkdwn", "text": f"*{ev['eventTypeCode']}* is in Status *{ev['statusCode']}*"}},
                              {"type": "context", "elements": [{"type": "mrkdwn", "text": f"{dt_f[0]}, {dt_f[1]} UTC"}]},
                              {"type": "divider"},
                              {"type": "section", "fields": [
                                      {"type": "mrkdwn", "text": "*Service:*"}, {"type": "plain_text", "text": f"{ev['service']}"},
                                      {"type": "mrkdwn", "text": "*Region:*"}, {"type": "plain_text", "text": f"{ev['region']}"},
                                      {"type": "mrkdwn", "text": "*Event Type Code:*"}, {"type": "plain_text", "text": f"{ev['eventTypeCode']}"},
                                      {"type": "mrkdwn", "text": "*Status:*"}, {"type": "plain_text", "text": f"{ev['statusCode']}"}
                                  ]
                              },
                              {"type": "section", "fields": [
                                      {"type": "mrkdwn", "text": "*Latest Description:*"}, {"type": "plain_text", "text": f"{lED}"},
                                      {"type": "mrkdwn", "text": "*Affected AWS services:*"}, {"type": "mrkdwn", "text": f"{iS}"}
                                  ]
                              },
                              {"type": "divider"},
                              {"type": "actions", "elements": [
                                      {"type": "button", "text": {"type": "plain_text", "text": "Go to Issue"}, "url": iUrl, "style": "primary"}
                                  ]
                              }
                          ]
                      }
                  ]
              }
              post_message(SHU, message)

          def post_message(url, message):
              request = Request(url, json.dumps(message).encode('utf-8'))
              try:
                  response = urlopen(request)
                  response.read()
                  logger.info("Message posted")
              except HTTPError as err:
                  logger.error("Request failed: %s %s", err.code, err.reason)
              except URLError as err:
                  logger.error("Server connection failed: %s", err.reason)

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt AwsHealthNotificationLambdaRole.Arn
      Environment:
        Variables:
          TeamsHookUrl: !Sub '${TeamsHookUrl}'
          SlackHookUrl: !Sub '${SlackHookUrl}'
          CheckTime: !Sub '${ExecutionRate}'
      Tags:
        - Key: Owner
          Value: !Ref TagOwner
        - Key: Type
          Value: !Ref TagType
        - Key: Usage
          Value: !Ref TagUsage

  AwsHealthNotificationEventRuleOnSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub 
        - '${ResourcePrefix}AwsHealthNotificationEventRuleOnSchedule'
        - { ResourcePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, '${AWS::StackName}-'] }
      Description: Scheduled rule to trigger check for AWS Health
      ScheduleExpression: !If [IsOneMinute, !Sub 'rate(${ExecutionRate} minute)', !Sub 'rate(${ExecutionRate} minutes)']
      Targets:
        - Arn: !GetAtt AwsHealthNotificationLambda.Arn
          Id: !Sub '${AWS::StackName}'
          Input: "{}"

  AwsHealthNotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties: 
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt AwsHealthNotificationLambda.Arn
      Principal: events.amazonaws.com
      SourceArn: !GetAtt AwsHealthNotificationEventRuleOnSchedule.Arn